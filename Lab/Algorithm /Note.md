
# Algorithm (อัลกอริทึม)
- ความหมาย: เป็นลำดับของขั้นตอนการทำงานที่ชัดเจนและจำกัด เพื่อแก้ปัญหาหรือทำงานบางอย่าง โดยอัลกอริทึมจะระบุขั้นตอนทั้งหมดที่จำเป็นต้องทำเพื่อให้ได้ผลลัพธ์ที่ต้องการ

- คุณสมบัติ:
  - มีจุดเริ่มต้นและจุดสิ้นสุดที่ชัดเจน
  - ลำดับขั้นตอนถูกกำหนดไว้อย่างเฉพาะเจาะจง
  - สามารถนำไปใช้ซ้ำได้

- ตัวอย่าง: อัลกอริทึมสำหรับการจัดเรียงข้อมูล (เช่น Bubble Sort, Quick Sort) หรือการค้นหาข้อมูล (เช่น Binary Search, Linear Search)

## Searching
1. Linear Search (การค้นหาเชิงเส้น):
- เป็นวิธีการค้นหาที่ง่ายที่สุด โดยตรวจสอบแต่ละองค์ประกอบในลิสต์หรืออาเรย์ทีละตัวจนกว่าจะพบค่าที่ต้องการ
  
### Concept
- เหมือนการที่เราเดินถามไปที่ละคน จนกว่าจะเจอคนที่ต้องการ

1. Binary Search (การค้นหาแบบทวิภาค):
- ใช้สำหรับค้นหาตัวเลขในอาร์เรย์ที่เรียงลำดับแล้ว โดยแบ่งครึ่งอาร์เรย์และเปรียบเทียบค่ากับค่ากลาง (mid) ในทุกครั้ง

### Concept
- Array [0,1,2,3,4,5,6,7,8,9,10]
- Val = 9, BEG = 0, END = 10, Mid = (BEG + END) / 2, A[Mid] = ?
- เหมือนแบบอยากหาค่า 9 แล้วหาค่า Mid ได้แล้ว 
- โดย Mid (0+10) / 2 และจะมีค่า A[Mid] = 5
- จากนั้นให้มาดูที่ 5 ว่า 9 อยู่ซ้ายหรือขวาแล้วเลือกฝั่ง เช่น ในตัวอย่าง Array ต้องเลือกฝั่งขวา
- จากนั้นก็ทำแบบเดิมจนกว่าจะได้ค่า Mid = 9 

## Sorting
1. Bubble Sort:
- ทำงานโดยเปรียบเทียบค่าที่อยู่ติดกันและสลับตำแหน่งถ้าค่าตัวแรกมากกว่าค่าตัวหลัง ทำซ้ำจนกว่าลิสต์จะเรียงลำดับสมบูรณ์

### Concept
- เหมือนเรียงแถวตามระดับความสูง เช่น คนที่สูงสลับกับคนที่เตี้ยกว่า

1. Merge Sort:
- เป็นการจัดเรียงแบบแยกและรวม (Divide and Conquer) โดยแยกข้อมูลเป็นครึ่งหนึ่งจนมีขนาดเล็กสุด แล้วค่อย ๆ รวมกลับมาโดยการจัดเรียงในแต่ละขั้นตอน

### Concept
- คือ การเอา array มาต่อกัน โดยการหาค่าตรงกลางก่อน Mid = (BEG + END) / 2 เพื่อหาค่า MID 
- และ ให้  I อยู่ฝั่ง BEG, J อยู่ฝั่ง END , Array 2 = temp 
- โดยเงื่อนไข ให้ทำการเปรียบเทียบค่า โดยการนำค่าที่น้อยกว่า ไปสำเนาที่ Array 2 และไล่ไปที่ละ Index เช่น MID = 3 
- Array1[1,2,3,4,5,6] สำเนาค่าน้อยทีละตัว -> Array2[1,2,...,6]

1. Quick Sort:
- เป็นการจัดเรียงที่เลือก "ตัวชี้" (pivot) แล้วแยกข้อมูลเป็นสองส่วนคือค่าที่น้อยกว่าหรือมากกว่า pivot หลังจากนั้นจะจัดเรียงแต่ละส่วนแยกกัน

- left = < น้อยกว่า
- right = > มากกว่า
- log = Located อยู่กับที่ 

ARRAY [25,10,18,27,36,45]

### Concept 
- ให้ left อยู่ฝั่งซ้ายสุดก็คือ 25 , right อยู่ฝั่งขวาสุดก็คือ 45
- โดยเงื่อนไข คือ เปรียบเทียบค่า ถ้ามีค่ามากให้อยู่ฝั่งขวา ถ้าค่าน้อยอยู่ฝั่งซ้าย
- โดยให้โยน loc ไปพร้อมกับตัวที่สลับ
- จังหวะสลับโยน loc มาด้วย เช่น loc, left -> loc, right

### Things to do
1. ต้องเปรียบเทียบเพื่อหาค่า mid 
2. จะหาค่า mid โดยทำการเปรียบเทียบเรื่อยๆจนกว่า left, right, loc จะตรงกัน
2. ระเบิด array ออกมาเป็น 2 ก้อน 
3. เปรียบเทียบ ทีละก้อน หาก ยังไม่ถูกต้อง ก็ระเบิดอีกครั้ง และทำเหมือนเดิม 
เช่น 18,10,25 -> 18,10 = 10,18
4. หาผลลัพธ์จากแต่ละรอบ 
- รอบ 1 = 25,10,18,27,36,45
- รอบ 2 = 36,45
- รอบ 3 = 18,10,25
- รอบ 4 = 10, 18
- Result = 10,18,25,27,36,45


## Data Hierarchy
- ความหมาย: Data Hierarchy เป็นโครงสร้างของข้อมูลที่จัดเรียงเป็นลำดับชั้นจากระดับต่ำไปหาสูง เพื่อให้เข้าใจได้ง่ายขึ้น โดยประกอบด้วยระดับต่างๆ ดังนี้:
  
- Bit: หน่วยที่เล็กที่สุดของข้อมูลในคอมพิวเตอร์ มีค่าเป็น 0 หรือ 1
- Byte: ประกอบด้วย 8 bits ใช้แทนข้อมูลต่างๆ เช่น ตัวอักษรหนึ่งตัว
- Field: กลุ่มของ Bytes ที่แทนข้อมูลชนิดเดียวกัน เช่น ชื่อ, อายุ
- Record: กลุ่มของ Fields ที่เกี่ยวข้องกัน ซึ่งแทนข้อมูลทั้งหมดของหนึ่งรายการ เช่น รายละเอียดของนักเรียนหนึ่งคน
- File: กลุ่มของ Records ที่มีลักษณะเดียวกัน เช่น ไฟล์ข้อมูลของนักเรียนทั้งหมด
- Database: กลุ่มของ Files ที่มีการเชื่อมโยงและจัดการข้อมูลแบบรวมศูนย์

### Files
- ความหมาย: Files เป็นที่เก็บข้อมูลในคอมพิวเตอร์ โดยข้อมูลในไฟล์อาจเป็นข้อความ, ตัวเลข, รูปภาพ หรือไฟล์เสียงก็ได้ ไฟล์แต่ละไฟล์มีชื่อ (filename) และชนิด (file extension) ที่ระบุประเภทของไฟล์ เช่น .txt, .c, .jpg

### File Openings
- ความหมาย: การเปิดไฟล์ในภาษา C ทำได้โดยใช้ฟังก์ชัน fopen() ซึ่งต้องระบุโหมดในการเปิดไฟล์ เช่น:
  - "r": เปิดไฟล์สำหรับอ่าน
  - "w": เปิดไฟล์สำหรับเขียน (ข้อมูลในไฟล์เดิมจะถูกลบ)
  - "a": เปิดไฟล์สำหรับเขียนต่อจากข้อมูลเดิม
  - "r+", "w+", "a+": เปิดไฟล์สำหรับทั้งอ่านและเขียน

### File Organizations
- ความหมาย: การจัดระเบียบไฟล์ (File Organization) หมายถึงวิธีการจัดเก็บข้อมูลในไฟล์ ซึ่งมีหลายรูปแบบ เช่น:
  - Sequential File Organization: จัดเก็บข้อมูลแบบเรียงตามลำดับ ถ้าต้องการค้นหาต้องอ่านไฟล์ตั้งแต่ต้นจนพบข้อมูลที่ต้องการ
  - Direct or Random File Organization: เข้าถึงข้อมูลได้โดยตรงโดยใช้คีย์เฉพาะ เช่น การเข้าถึงข้อมูลในตำแหน่งที่ระบุ
  - Indexed File Organization: จัดเก็บข้อมูลโดยมีดัชนีช่วยในการค้นหาข้อมูลได้เร็วขึ้น

## Big O Notation 
- เป็นวิธีการใช้เพื่อวัดประสิทธิภาพของอัลกอริทึมในแง่ของเวลาในการทำงาน (Time Complexity) หรือหน่วยความจำที่ใช้ (Space Complexity) โดยจะบอกถึงการเติบโตของอัลกอริทึมเมื่อขนาดของข้อมูล (n) เพิ่มขึ้น ซึ่งจะช่วยให้สามารถประเมินได้ว่าอัลกอริทึมใดมีประสิทธิภาพมากกว่ากัน

#### ประเภทของ Big O Notation
1. O(1) - Constant Time: เวลาในการทำงานไม่เปลี่ยนแปลงตามขนาดของข้อมูล เช่น การเข้าถึงสมาชิกในอาร์เรย์โดยใช้ดัชนี

int getFirstElement(int arr[]) {
    return arr[0]; // O(1)
}

2. O(n) - Linear Time: เวลาในการทำงานเพิ่มขึ้นตามขนาดของข้อมูล เช่น การวนลูปผ่านสมาชิกในอาร์เรย์ทั้งหมด

void printAllElements(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]); // O(n)
    }
}

3. O(n) - Linear Time: เวลาในการทำงานเพิ่มขึ้นตามขนาดของข้อมูล เช่น การวนลูปผ่านสมาชิกในอาร์เรย์ทั้งหมด

void printAllPairs(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("(%d, %d) ", arr[i], arr[j]); // O(n^2)
        }
    }
}

4. O(log n) - Logarithmic Time: เวลาในการทำงานเพิ่มขึ้นตามลอการิทึมของขนาดข้อมูล เช่น การค้นหาแบบ Binary Search

int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid; // O(log n)
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // Target not found
}

5. O(n log n) - Linearithmic Time: เวลาในการทำงานเพิ่มขึ้นเป็นเส้นตรงคูณกับลอการิทึมของขนาดข้อมูล เช่น การเรียงลำดับแบบ Merge Sort หรือ Quick Sort

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid); // O(n log n)
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

6. O(2^n) - Exponential Time: เวลาในการทำงานเพิ่มขึ้นเป็นสองเท่าของขนาดข้อมูล เช่น อัลกอริทึมที่เกี่ยวกับการคำนวณฟีโบนัชชี่แบบเรียกซ้ำ

int fibonacci(int n) {
    if (n <= 1) {
        return n; // O(2^n)
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

7. O(n!) - Factorial Time: เวลาในการทำงานเพิ่มขึ้นตามแฟกทอเรียลของขนาดข้อมูล เช่น การจัดเรียงแบบ Permutation

void permute(char* str, int left, int right) {
    if (left == right) {
        printf("%s\n", str); // O(n!)
    } else {
        for (int i = left; i <= right; i++) {
            swap((str + left), (str + i));
            permute(str, left + 1, right);
            swap((str + left), (str + i)); // backtrack
        }
    }
}

#### สรุป
- Big O Notation ช่วยบอกถึงความซับซ้อนของอัลกอริทึมโดยไม่สนใจรายละเอียดของฮาร์ดแวร์หรือซอฟต์แวร์
- เลขยกกำลังสูงและแฟกทอเรียลมีการเติบโตที่รวดเร็วที่สุด และอัลกอริทึมที่ซับซ้อนควรหลีกเลี่ยง